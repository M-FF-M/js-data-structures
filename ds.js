class AVLTreeNode{constructor(o,p){this.cmpFct=o,this.h=0,this.key=p,this.balance=0,this.left=null,this.right=null}height(){return this.h}leftHeight(){return null==this.left?0:this.left.height()+1}rightHeight(){return null==this.right?0:this.right.height()+1}heightDiff(){return this.balance=this.rightHeight()-this.leftHeight()}find(o){return!(0!=this.cmpFct(o,this.key.data))||(0<this.cmpFct(o,this.key.data)?null!=this.right&&this.right.find(o):null!=this.left&&this.left.find(o))}findRightChild(o,p,t){if(null!=this.right){const x=this.right.findRightChild(this,!0,t);if(t){if(this.h=Math.max(this.leftHeight(),this.rightHeight()),this.heightDiff(),null==o)throw new Error("Can't rebalance tree without knowing the parent node");p?o.right=this.checkForValidity():o.left=this.checkForValidity()}return x}const x=this;if(t){if(null==o)throw new Error("Can't remove node without knowing the parent node");null==this.left?(p?o.right=null:o.left=null,this.left=null,this.right=null):(p?o.right=this.left:o.left=this.left,this.left=null,this.right=null),this.h=0}return x}findLeftChild(){return null==this.left?this.key.data:this.left.findLeftChild()}insert(o,p){const t=this.insertHelper(o,p);if(t!=this)throw new Error("Insert requested a parent node change. Use insertHelper instead.")}remove(o,p){const t=this.removeHelper(o,p);if(t!=this)throw new Error("Remove requested a parent node change. Use removeHelper instead.")}insertHelper(o,p){return 0==this.cmpFct(o.data,this.key.data)?this:(0<this.cmpFct(o.data,this.key.data)?null==this.right?(p.insertLinkAfter(this.key,o),this.right=new AVLTreeNode(this.cmpFct,o)):this.right=this.right.insertHelper(o,p):null==this.left?(p.insertLinkBefore(this.key,o),this.left=new AVLTreeNode(this.cmpFct,o)):this.left=this.left.insertHelper(o,p),this.h=Math.max(this.leftHeight(),this.rightHeight()),this.heightDiff(),this.checkForValidity())}removeHelper(o,p){if(0==this.cmpFct(o,this.key.data)){if(p.removeLink(this.key),null!=this.left&&null!=this.right){const t=this.left.findRightChild(this,!1,!0);return t.left=this.left,t.right=this.right,t.h=Math.max(t.leftHeight(),t.rightHeight()),t.heightDiff(),t.checkForValidity()}return null==this.left?null==this.right?null:this.right:this.left}return 0<this.cmpFct(o,this.key.data)?null!=this.right&&(this.right=this.right.removeHelper(o,p)):null!=this.left&&(this.left=this.left.removeHelper(o,p)),this.h=Math.max(this.leftHeight(),this.rightHeight()),this.heightDiff(),this.checkForValidity()}checkForValidity(){if(1>=Math.abs(this.heightDiff()))return this;let o=this.right,p=!1,t=1;if(0>this.heightDiff()&&(o=this.left,p=!0,t=-1),0<=o.heightDiff()*t){const x=o.left,y=o.right;if(p){const z=this.left;return this.left=y,this.h=Math.max(this.leftHeight(),this.rightHeight()),this.heightDiff(),z.left=x,z.right=this,z.h=Math.max(z.leftHeight(),z.rightHeight()),z.heightDiff(),z}const z=this.right;return this.right=x,this.h=Math.max(this.leftHeight(),this.rightHeight()),this.heightDiff(),z.left=this,z.right=y,z.h=Math.max(z.leftHeight(),z.rightHeight()),z.heightDiff(),z}const x=o.left,y=o.right;if(p){const z=this.left,A=y.left,B=y.right;return this.left=B,this.h=Math.max(this.leftHeight(),this.rightHeight()),this.heightDiff(),z.right=A,z.h=Math.max(z.leftHeight(),z.rightHeight()),z.heightDiff(),y.left=z,y.right=this,y.h=Math.max(y.leftHeight(),y.rightHeight()),y.heightDiff(),y}const z=this.right,A=x.left,B=x.right;return this.right=A,this.h=Math.max(this.leftHeight(),this.rightHeight()),this.heightDiff(),z.left=B,z.h=Math.max(z.leftHeight(),z.rightHeight()),z.heightDiff(),x.left=this,x.right=z,x.h=Math.max(x.leftHeight(),x.rightHeight()),x.heightDiff(),x}toString(){return this.dotNode(0)[0]}dotNode(o){let p="\t"+o+" [label=\""+this.key.data+", b="+this.balance+"\"];\n",t=o+1;if(null!=this.left){const[x,y]=this.left.dotLink(o,t,"l");p+=x,t=y}if(null!=this.right){const[x,y]=this.right.dotLink(o,t,"r");p+=x,t=y}return[p,t]}dotLink(o,p,t){let x="\t"+o+" -> "+p+" [label=\""+t+"\"];\n";const[y,z]=this.dotNode(p);return x+=y,p=z,[x,p]}}class AVLTree{constructor(o=(p,t)=>p-t){this.cmpFct=o,this.root=null,this.list=new DoublyLinkedList}get length(){return this.list.length}insert(o){if(null==this.root){const p=this.list.pushBack(o);this.root=new AVLTreeNode(this.cmpFct,p)}else{const p=new DoubleLink(o,null,null);this.root=this.root.insertHelper(p,this.list)}}remove(o){null==this.root||(1==this.length?this.root.key.data==o&&(this.list.popBack(),this.root=null):this.root=this.root.removeHelper(o,this.list))}find(o){return null!=this.root&&this.root.find(o)}contains(o){return this.find(o)}toArray(){return this.list.toArray()}toString(){let o="digraph {\n";return null!=this.root&&(o+=this.root.toString()),o+="}",o}isEmpty(){return 0==this.length}}class TreeSet extends AVLTree{constructor(o=(p,t)=>p-t){super(o)}}class BinaryHeap{constructor(...o){if(this.data=[],this.length=0,0<o.length){o[0]instanceof Array&&(o=o[0]),this.data=o.slice(),this.length=this.data.length;for(let p=Math.floor(this.length/2)-1;0<=p;p--)this.siftDown(p)}}swap(o,p){let t=this.data[o];this.data[o]=this.data[p],this.data[p]=t}siftUp(o){for(;0<o&&this.data[Math.floor((o-1)/2)]>this.data[o];)this.swap(o,Math.floor((o-1)/2)),o=Math.floor((o-1)/2)}siftDown(o){for(let p;2*o+1<this.length;){if(p=2*o+2>=this.length?2*o+1:this.data[2*o+1]<this.data[2*o+2]?2*o+1:2*o+2,this.data[o]<=this.data[p])return;this.swap(o,p),o=p}}min(){if(0==this.length)throw new RangeError("BinaryHeap: can't call min() on an empty heap.");return this.data[0]}deleteMin(){let o=this.data[0];return this.length--,this.data[0]=this.data[this.length],this.data.pop(),this.siftDown(0),o}insert(o){this.data[this.length]=o,this.siftUp(this.length),this.length++}isEmpty(){return 0==this.length}}class CustomBinaryHeap{constructor(o=(t,x)=>t-x,...p){if(this.data=[],this.cmpFct=o,this.length=0,0<p.length){p[0]instanceof Array&&(p=p[0]),this.data=p.slice(),this.length=this.data.length;for(let t=Math.floor(this.length/2)-1;0<=t;t--)this.siftDown(t)}}swap(o,p){let t=this.data[o];this.data[o]=this.data[p],this.data[p]=t}siftUp(o){for(;0<o&&0<this.cmpFct(this.data[Math.floor((o-1)/2)],this.data[o]);)this.swap(o,Math.floor((o-1)/2)),o=Math.floor((o-1)/2)}siftDown(o){for(let p;2*o+1<this.length;){if(p=2*o+2>=this.length?2*o+1:0>this.cmpFct(this.data[2*o+1],this.data[2*o+2])?2*o+1:2*o+2,0>=this.cmpFct(this.data[o],this.data[p]))return;this.swap(o,p),o=p}}min(){if(0==this.length)throw new RangeError("BinaryHeap: can't call min() on an empty heap.");return this.data[0]}deleteMin(){let o=this.data[0];return this.length--,this.data[0]=this.data[this.length],this.data.pop(),this.siftDown(0),o}insert(o){this.data[this.length]=o,this.siftUp(this.length),this.length++}isEmpty(){return 0==this.length}}class PriorityQueue extends CustomBinaryHeap{constructor(o=(t,x)=>t-x,...p){super(o,...p)}}class BinomialTreeNode{constructor(o){this.key=o,this.children=[]}min(){return this.key}rank(){return this.children.length}deleteMin(){const o=this.children.slice();return this.children=[],o}addChild(o){if(!(o instanceof BinomialTreeNode))throw new Error("BinomialTreeNode: child must be of type BinomialTreeNode.");if(o.rank()!=this.rank())throw new Error("BinomialTreeNode: Can't add tree of rank "+o.rank()+" to a tree of rank "+this.rank()+".");return this.children.push(o),this}}function merge(o,p){return o.min()<=p.min()?o.addChild(p):p.addChild(o)}class BinomialHeap{constructor(...o){if(this.trees=[],this.length=0,0<o.length)if(o[0]instanceof Array&&(o=o[0]),1==o.length&&!(o[0]instanceof BinomialTreeNode))this.trees.push(new BinomialTreeNode(o[0])),this.length=1;else for(let p=0;p<o.length;p++)this.trees.push(o[p]),this.length+=1<<o[p].rank()}min(){if(0==this.trees.length)throw new RangeError("BinomialHeap: can't call min() on an empty heap.");let o=Infinity;for(let p=0;p<this.trees.length;p++)this.trees[p].min()<o&&(o=this.trees[p].min());return o}insert(o){const p=new BinomialHeap(o);this.mergeWith(p)}deleteMin(){if(0==this.trees.length)throw new RangeError("Can't call deleteMin() on an empty heap.");let o=Infinity,p=null,t=0;for(let y=0;y<this.trees.length;y++)this.trees[y].min()<o&&(o=this.trees[y].min(),p=this.trees[y],t=y);const x=new BinomialHeap(p.deleteMin());return this.length-=x.length+1,this.trees.splice(t,1),this.mergeWith(x),o}mergeWith(o){let p=0,t=0;const x=[];let y=-1;for(this.length+=o.length;p<this.trees.length||t<o.trees.length;){let z=null,A=null,B=Infinity,C=Infinity;if(p<this.trees.length&&(z=this.trees[p],B=z.rank()),t<o.trees.length&&(A=o.trees[t],C=A.rank()),B<C)p++;else if(B>C){t++;const F=C,G=A;C=B,A=z,B=F,z=G}let D;if(B==C?(p++,t++,D=merge(z,A)):D=z,D.rank()>y)x.push(D),y=D.rank();else{if(D.rank()<y)throw new Error("The developer obviously didn't understand how binomial heaps work...");D=merge(D,x[x.length-1]),x[x.length-1]=D,y=D.rank()}}this.trees=x}isEmpty(){return 0==this.trees.length}}class E{constructor(o){this.v=o}}class WE{constructor(o,p){this.v=o,this.w=p}}class Graph{constructor(o){this.n=o,this.weighted=!1,this.adjList=[],this.adjListRev=[],this.nodeMap=new Map;for(let p=0;p<this.n;p++)this.adjList[p]=[],this.adjListRev[p]=[]}getSCCGraph(){const o=[],p=[],t=[],x=-1,y=0,A=[];let B=0;for(let J=0;J<this.n;J++)o[J]=x,p[J]=x,t[J]=x,A[J]=-1;const C=new Queue,D=new Queue,F=[],G=[],H=J=>{const K=new Set;o[J]=p[J]=B++,C.pushBack(J),D.pushBack(K),t[J]=y;for(let L=0;L<this.adjList[J].length;L++){const M=this.adjList[J][L].v;if(p[M]==x){const N=H(M);-1!=N&&K.add(N)}else-1!=A[M]&&K.add(A[M]);t[M]==y&&(o[J]=Math.min(o[J],o[M]))}if(o[J]==p[J]){const L=[];for(;;){const M=C.popBack();t[M]=1,A[M]=F.length,L.push(this.getNode(M));const N=D.popBack();if(J==M)break;for(const O of N)K.add(O)}F.push(L);for(const M of K)G.push([F.length-1,M]);return F.length-1}return-1};for(let J=0;J<this.n;J++)p[J]==x&&H(J);const I=new Graph(F.length);for(let J=0;J<G.length;J++)I.insertEdge(G[J][0],G[J][1]);for(let J=0;J<F.length;J++)I.setNode(J,F[J]);return I}topSort(){const o=[];let p=0;const t=[],x=new Queue;for(let y=0;y<this.n;y++)o[y]=this.adjList[y].length,0==o[y]&&(p++,x.pushBack(y),t.push(this.getNode(y)));for(;!x.isEmpty();){const y=x.popFront();for(let z=0;z<this.adjListRev[y].length;z++){const A=this.adjListRev[y][z].v;o[A]--,0==o[A]&&(p++,x.pushBack(A),t.push(this.getNode(A)))}}return p==this.n?t.reverse():null}isAcyclic(){return null!==this.topSort()}insertEdge(o,p,t){"number"==typeof t?(this.adjList[o].push(new WE(p,t)),this.adjListRev[p].push(new WE(o,t)),this.weighted=!0):(this.adjList[o].push(new E(p)),this.adjListRev[p].push(new E(o)))}insertUndirectedEdge(o,p,t){this.insertEdge(o,p,t),this.insertEdge(p,o,t)}getNode(o){return this.nodeMap.has(o)?this.nodeMap.get(o):o}setNode(o,p){this.nodeMap.set(o,p)}getAllNodes(){const o=[];for(let p=0;p<this.n;p++)o.push(this.getNode(p));return o}}class HashSet{constructor(o=p=>p){this.toKeyFct=o,this.hashMap={},this.length=0}insert(o){this.hashMap.hasOwnProperty(this.toKeyFct(o))||(this.hashMap[this.toKeyFct(o)]=o,this.length++)}remove(o){this.hashMap.hasOwnProperty(this.toKeyFct(o))&&(this.hashMap[this.toKeyFct(o)]=void 0,delete this.hashMap[this.toKeyFct(o)],this.length--)}find(o){return this.hashMap.hasOwnProperty(this.toKeyFct(o))}contains(o){return this.find(o)}toArray(){const o=[];for(const p in this.hashMap)this.hashMap.hasOwnProperty(p)&&o.push(this.hashMap[p]);return o}isEmpty(){return 0==this.length}}class ListHashSet{constructor(o=p=>p){this.toKeyFct=o,this.hashMap={},this.list=new DoublyLinkedList}get length(){return this.list.length}insert(o){"undefined"==typeof this.hashMap[this.toKeyFct(o)]&&(this.hashMap[this.toKeyFct(o)]=this.list.pushBack(o))}remove(o){"undefined"!=typeof this.hashMap[this.toKeyFct(o)]&&(this.list.removeLink(this.hashMap[this.toKeyFct(o)]),this.hashMap[this.toKeyFct(o)]=void 0)}find(o){return"undefined"!=typeof this.hashMap[this.toKeyFct(o)]}contains(o){return this.find(o)}toArray(){return this.list.toArray()}isEmpty(){return 0==this.length}}class SingleLink{constructor(o,p){this.data=o,this.next=p}}class DoubleLink{constructor(o,p,t){this.data=o,this.last=p,this.next=t}}class LinkedList{constructor(...o){if(1==o.length&&o[0]instanceof Array&&(o=o[0]),this.length=0,this.first=null,0<o.length){o=o.slice().reverse(),this.length=o.length,this.first=new SingleLink(o[0],null);let p=this.first;for(let t=1;t<this.length;t++)p.next=new SingleLink(o[t],null),p=p.next}}get(o){if(0>o)throw new RangeError("LinkedList: index "+o+" is out of bounds length is "+this.length+".");if(o>=this.length)throw new RangeError("LinkedList: index "+o+" is out of bounds length is "+this.length+".");o=this.length-o-1;let p=this.first;for(let t=0;t<this.length;t++){if(t==o)return p.data;p=p.next}}removeIdx(o){if(0>o)throw new RangeError("LinkedList: index "+o+" is out of bounds length is "+this.length+".");if(o>=this.length)throw new RangeError("LinkedList: index "+o+" is out of bounds length is "+this.length+".");if(o=this.length-o-1,0==o)this.first=this.first.next;else{let p=this.first,t=this.first.next;for(let x=1;x<this.length;x++){if(x==o){p.next=t.next;break}p=t,t=t.next}}this.length--}removeObj(o){let p=!1;if(o===this.first.data)this.first=this.first.next,p=!0;else{let t=this.first,x=this.first.next;for(let y=1;y<this.length;y++){if(o===x.data){t.next=x.next,p=!0;break}t=x,x=x.next}}return p&&this.length--,p}contains(o){let p=this.first;for(let t=0;t<this.length;t++){if(o===p.data)return!0;p=p.next}return!1}pushBack(o){this.first=new SingleLink(o,this.first),this.length++}getBack(){if(0==this.length)throw new RangeError("LinkedList: cannot get last element from empty list.");return this.first.data}popBack(){if(0==this.length)throw new RangeError("LinkedList: cannot pop last element from empty list.");const o=this.first.data;return this.first=this.first.next,this.length--,o}isEmpty(){return 0==this.length}toString(){let o="]",p=this.first;for(let t=0;t<this.length;t++)0<t&&(o=", "+o),o=p.data+o,p=p.next;return o="LinkedList: ["+o,o}}class DoublyLinkedList{constructor(...o){if(1==o.length&&o[0]instanceof Array&&(o=o[0]),this.length=0,this.first=null,this.last=null,0<o.length){this.length=o.length,this.first=new DoubleLink(o[0],null,null);let p=this.first;for(let t=1;t<this.length;t++)p.next=new DoubleLink(o[t],p,null),p=p.next;this.last=p}}get(o){if(0>o)throw new RangeError("DoublyLinkedList: index "+o+" is out of bounds length is "+this.length+".");if(o>=this.length)throw new RangeError("DoublyLinkedList: index "+o+" is out of bounds length is "+this.length+".");let p=this.first;for(let t=0;t<this.length;t++){if(t==o)return p.data;p=p.next}}removeIdx(o){if(0>o)throw new RangeError("DoublyLinkedList: index "+o+" is out of bounds length is "+this.length+".");if(o>=this.length)throw new RangeError("DoublyLinkedList: index "+o+" is out of bounds length is "+this.length+".");if(0==o)this.first=this.first.next,null!==this.first&&(this.first.last=null);else{let p=this.first,t=this.first.next;for(let x=1;x<this.length;x++){if(x==o){p.next=t.next,null===t.next?this.last=p:t.next.last=p;break}p=t,t=t.next}}this.length--}removeObj(o){let p=!1;if(o===this.first.data)this.first=this.first.next,null!==this.first&&(this.first.last=null),p=!0;else{let t=this.first,x=this.first.next;for(let y=1;y<this.length;y++){if(o===x.data){t.next=x.next,null===x.next?this.last=t:x.next.last=t,p=!0;break}t=x,x=x.next}}return p&&this.length--,p}removeLink(o){if(0==this.length)throw new RangeError("DoublyLinkedList: cannot remove element from empty list.");if(null==o.last&&null==o.next){if(this.first!=o||1!=this.length)throw new Error("DoublyLinkedList: cannot remove link that is not part of the list");this.first=this.last=null}else if(null==o.last){if(this.first!=o)throw new Error("DoublyLinkedList: cannot remove link that is not part of the list");this.first=o.next,o.next.last=null}else if(null==o.next){if(this.last!=o)throw new Error("DoublyLinkedList: cannot remove link that is not part of the list");this.last=o.last,o.last.next=null}else{const p=o.next,t=o.last;p.last=t,t.next=p}this.length--}insertAfter(o,p){const t=o.next;if(null==t){if(this.last!=o)throw new Error("DoublyLinkedList: cannot add element after link that is not part of the list");return this.pushBack(p)}const x=o.next=t.last=new DoubleLink(p,o,t);return this.length++,x}insertBefore(o,p){const t=o.last;if(null==t){if(this.first!=o)throw new Error("DoublyLinkedList: cannot add element before link that is not part of the list");return this.pushFront(p)}const x=o.last=t.next=new DoubleLink(p,t,o);return this.length++,x}insertLinkAfter(o,p){const t=o.next;if(null==t){if(this.last!=o)throw new Error("DoublyLinkedList: cannot add element after link that is not part of the list");return this.last=p,this.last.next=null,this.last.last=o,o.next=this.last,this.length++,p}const x=o.next=t.last=p;return p.last=o,p.next=t,this.length++,x}insertLinkBefore(o,p){const t=o.last;if(null==t){if(this.first!=o)throw new Error("DoublyLinkedList: cannot add element before link that is not part of the list");return this.first=p,this.first.last=null,this.first.next=o,o.last=this.first,this.length++,p}const x=o.last=t.next=p;return p.last=t,p.next=o,this.length++,x}contains(o){let p=this.first;for(let t=0;t<this.length;t++){if(o===p.data)return!0;p=p.next}return!1}pushBack(o){let p;return 0==this.length?p=this.last=this.first=new DoubleLink(o,null,null):(p=this.last.next=new DoubleLink(o,this.last,null),this.last=this.last.next),this.length++,p}getBack(){if(0==this.length)throw new RangeError("DoublyLinkedList: cannot get last element from empty list.");return this.last.data}popBack(){if(0==this.length)throw new RangeError("DoublyLinkedList: cannot pop last element from empty list.");const o=this.last.data;return this.last=this.last.last,null===this.last?this.first=null:this.last.next=null,this.length--,o}pushFront(o){let p;return 0==this.length?p=this.last=this.first=new DoubleLink(o,null,null):(p=this.first.last=new DoubleLink(o,null,this.first),this.first=this.first.last),this.length++,p}getFront(){if(0==this.length)throw new RangeError("DoublyLinkedList: cannot get first element from empty list.");return this.first.data}popFront(){if(0==this.length)throw new RangeError("DoublyLinkedList: cannot pop first element from empty list.");const o=this.first.data;return this.first=this.first.next,null===this.first?this.last=null:this.first.last=null,this.length--,o}toArray(){const o=[];let p=this.first;for(let t=0;t<this.length;t++)o.push(p.data),p=p.next;return o}isEmpty(){return 0==this.length}toString(){let o="DoublyLinkedList: [",p=this.first;for(let t=0;t<this.length;t++)0<t&&(o+=", "),o+=p.data,p=p.next;return o+="]",o}}class Queue{constructor(...o){1==o.length&&o[0]instanceof Array&&(o=o[0]),this.data=o.slice(),this.front=0,this.last=o.length-1,this.size=16,0<o.length?this.size=Math.max(16,1<<Math.ceil(Math.log2(o.length))):this.front=1}get(o){if(0>o)throw new RangeError("Queue: index "+o+" is out of bounds length is "+this.length+".");if(o>=this.length)throw new RangeError("Queue: index "+o+" is out of bounds length is "+this.length+".");return this.data[(this.front+o)%this.size]}contains(o){for(let p=0;p<this.length;p++)if(this.data[(this.front+p)%this.size]===o)return!0;return!1}removeObj(o){let p=-1;for(let t=0;t<this.length;t++)if(this.data[(this.front+t)%this.size]===o){p=t;break}return-1!=p&&(this.removeIdx(p),!0)}removeIdx(o){if(0>o)throw new RangeError("Queue: index "+o+" is out of bounds length is "+this.length+".");if(o>=this.length)throw new RangeError("Queue: index "+o+" is out of bounds length is "+this.length+".");for(let p=o;p<this.length;p++)this.data[p%this.size]=this.data[(p+1)%this.size];--this.last,0>this.last&&(this.last=this.size-1),this.checkFrontShift()}get length(){return 0>this.last?0:this.last>=this.front?this.last-this.front+1:this.size-this.front+this.last+1}checkFrontShift(){if(this.length<this.size/4){let o=[];for(let p=0;p<this.length;p++)o[p]=this.data[(this.front+p)%this.size];this.data=o,this.front=0,this.last=this.data.length-1,this.size=Math.max(16,1<<Math.ceil(Math.log2(this.data.length)),this.size/2)}}pushBack(o){if(0==this.length)this.data.push(o),this.front=this.last=0;else if(this.last>=this.front)this.data[++this.last]=o,this.last>=this.size&&(this.size*=2);else if(this.last<this.front-1)this.data[++this.last]=o;else{for(let p=0;p<this.size-this.front;p++)this.data[this.front+this.size+p]=this.data[this.front+p];this.front+=this.size,this.size*=2,this.data[++this.last]=o}}getBack(){if(0==this.length)throw new RangeError("Queue: cannot get last element from empty queue.");return this.data[this.last]}popBack(){if(0==this.length)throw new RangeError("Queue: cannot pop last element from empty queue.");const o=this.data[this.last];return 1==this.length?(this.data=[],this.front=1,this.last=-1,this.size=16,o):(--this.last,0>this.last&&(this.last=this.size-1),this.checkFrontShift(),o)}pushFront(o){if(0==this.length)this.data.push(o),this.front=this.last=0;else if(this.last>=this.front)0<this.front?this.data[--this.front]=o:(this.last==this.size-1&&(this.size*=2),this.front=this.size-1,this.data[this.front]=o);else if(this.last<this.front-1)this.data[--this.front]=o;else{for(let p=0;p<this.size-this.front;p++)this.data[this.front+this.size+p]=this.data[this.front+p];this.front+=this.size,this.size*=2,this.data[--this.front]=o}}getFront(){if(0==this.length)throw new RangeError("Queue: cannot get last element from empty queue.");return this.data[this.front]}popFront(){if(0==this.length)throw new RangeError("Queue: cannot pop first element from empty queue.");const o=this.data[this.front];return 1==this.length?(this.data=[],this.front=1,this.last=-1,this.size=16,o):(++this.front,this.front>=this.size&&(this.front=0),this.checkFrontShift(),o)}isEmpty(){return 0==this.length}toString(){let o="Queue: [";for(let p=0;p<this.length;p++)0<p&&(o+=", "),o+=this.data[(this.front+p)%this.size];return o+="]",o}}