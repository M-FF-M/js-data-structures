class AVLTreeNode{constructor(a,b){this._cmpFct=a,this.h=0,this.key=b,this.balance=0,this.left=null,this.right=null}height(){return this.h}_leftHeight(){return null==this.left?0:this.left.height()+1}_rightHeight(){return null==this.right?0:this.right.height()+1}_heightDiff(){return this.balance=this._rightHeight()-this._leftHeight()}find(a){return!(0!=this._cmpFct(a,this.key.data))||(0<this._cmpFct(a,this.key.data)?null!=this.right&&this.right.find(a):null!=this.left&&this.left.find(a))}findRightChild(a,b,c){if(null!=this.right){const d=this.right.findRightChild(this,!0,c);if(c){if(this.h=Math.max(this._leftHeight(),this._rightHeight()),this._heightDiff(),null==a)throw new Error("Can't rebalance tree without knowing the parent node");b?a.right=this.checkForValidity():a.left=this.checkForValidity()}return d}else{const d=this;if(c){if(null==a)throw new Error("Can't remove node without knowing the parent node");null==this.left?(b?a.right=null:a.left=null,this.left=null,this.right=null):(b?a.right=this.left:a.left=this.left,this.left=null,this.right=null),this.h=0}return d}}findLeftChild(){return null==this.left?this.key.data:this.left.findLeftChild()}insert(a,b){const c=this.insertHelper(a,b);if(c!=this)throw new Error("Insert requested a parent node change. Use insertHelper instead.")}remove(a,b){const c=this.removeHelper(a,b);if(c!=this)throw new Error("Remove requested a parent node change. Use removeHelper instead.")}insertHelper(a,b){return 0==this._cmpFct(a.data,this.key.data)?this:(0<this._cmpFct(a.data,this.key.data)?null==this.right?(b.insertLinkAfter(this.key,a),this.right=new AVLTreeNode(this._cmpFct,a)):this.right=this.right.insertHelper(a,b):null==this.left?(b.insertLinkBefore(this.key,a),this.left=new AVLTreeNode(this._cmpFct,a)):this.left=this.left.insertHelper(a,b),this.h=Math.max(this._leftHeight(),this._rightHeight()),this._heightDiff(),this.checkForValidity())}removeHelper(a,b){if(0==this._cmpFct(a,this.key.data)){if(b.removeLink(this.key),null!=this.left&&null!=this.right){const a=this.left.findRightChild(this,!1,!0);return a.left=this.left,a.right=this.right,a.h=Math.max(a._leftHeight(),a._rightHeight()),a._heightDiff(),a.checkForValidity()}return null==this.left?null==this.right?null:this.right:this.left}return 0<this._cmpFct(a,this.key.data)?null!=this.right&&(this.right=this.right.removeHelper(a,b)):null!=this.left&&(this.left=this.left.removeHelper(a,b)),this.h=Math.max(this._leftHeight(),this._rightHeight()),this._heightDiff(),this.checkForValidity()}checkForValidity(){if(1>=Math.abs(this._heightDiff()))return this;let a=this.right,b=!1,c=1;if(0>this._heightDiff()&&(a=this.left,b=!0,c=-1),0<=a._heightDiff()*c){const c=a.left,d=a.right;if(b){const a=this.left;return this.left=d,this.h=Math.max(this._leftHeight(),this._rightHeight()),this._heightDiff(),a.left=c,a.right=this,a.h=Math.max(a._leftHeight(),a._rightHeight()),a._heightDiff(),a}else{const a=this.right;return this.right=c,this.h=Math.max(this._leftHeight(),this._rightHeight()),this._heightDiff(),a.left=this,a.right=d,a.h=Math.max(a._leftHeight(),a._rightHeight()),a._heightDiff(),a}}else{const c=a.left,d=a.right;if(b){const a=this.left,b=d.left,c=d.right;return this.left=c,this.h=Math.max(this._leftHeight(),this._rightHeight()),this._heightDiff(),a.right=b,a.h=Math.max(a._leftHeight(),a._rightHeight()),a._heightDiff(),d.left=a,d.right=this,d.h=Math.max(d._leftHeight(),d._rightHeight()),d._heightDiff(),d}else{const a=this.right,b=c.left,d=c.right;return this.right=b,this.h=Math.max(this._leftHeight(),this._rightHeight()),this._heightDiff(),a.left=d,a.h=Math.max(a._leftHeight(),a._rightHeight()),a._heightDiff(),c.left=this,c.right=a,c.h=Math.max(c._leftHeight(),c._rightHeight()),c._heightDiff(),c}}}toString(){return this._dotNode(0)[0]}_dotNode(a){let b="\t"+a+" [label=\""+this.key.data+", b="+this.balance+"\"];\n",c=a+1;if(null!=this.left){const[d,e]=this.left._dotLink(a,c,"l");b+=d,c=e}if(null!=this.right){const[d,e]=this.right._dotLink(a,c,"r");b+=d,c=e}return[b,c]}_dotLink(a,b,c){let d="\t"+a+" -> "+b+" [label=\""+c+"\"];\n";const[e,f]=this._dotNode(b);return d+=e,b=f,[d,b]}}class AVLTree{constructor(a=(c,a)=>c-a){this._cmpFct=a,this._root=null,this._list=new DoublyLinkedList}get length(){return this._list.length}insert(a){if(null==this._root){const b=this._list.pushBack(a);this._root=new AVLTreeNode(this._cmpFct,b)}else{const b=new DoubleLink(a,null,null);this._root=this._root.insertHelper(b,this._list)}}remove(a){null==this._root||(1==this.length?this._root.key.data==a&&(this._list.popBack(),this._root=null):this._root=this._root.removeHelper(a,this._list))}find(a){return null!=this._root&&this._root.find(a)}contains(a){return this.find(a)}toArray(){return this._list.toArray()}toString(){let a="digraph {\n";return null!=this._root&&(a+=this._root.toString()),a+="}",a}isEmpty(){return 0==this.length}}class TreeSet extends AVLTree{constructor(a=(c,a)=>c-a){super(a)}}class BinaryHeap{constructor(...a){if(this._data=[],this.length=0,0<a.length){a[0]instanceof Array&&(a=a[0]),this._data=a.slice(),this.length=this._data.length;for(let a=Math.floor(this.length/2)-1;0<=a;a--)this._siftDown(a)}}_swap(a,b){let c=this._data[a];this._data[a]=this._data[b],this._data[b]=c}_siftUp(a){for(;0<a&&this._data[Math.floor((a-1)/2)]>this._data[a];)this._swap(a,Math.floor((a-1)/2)),a=Math.floor((a-1)/2)}_siftDown(a){for(let b;2*a+1<this.length;){if(b=2*a+2>=this.length?2*a+1:this._data[2*a+1]<this._data[2*a+2]?2*a+1:2*a+2,this._data[a]<=this._data[b])return;this._swap(a,b),a=b}}min(){if(0==this.length)throw new RangeError("BinaryHeap: can't call min() on an empty heap.");return this._data[0]}deleteMin(){let a=this._data[0];return this.length--,this._data[0]=this._data[this.length],this._data.pop(),this._siftDown(0),a}insert(a){this._data[this.length]=a,this._siftUp(this.length),this.length++}isEmpty(){return 0==this.length}}class CustomBinaryHeap{constructor(a=(c,a)=>c-a,...b){if(this._data=[],this.cmpFct=a,this.length=0,0<b.length){b[0]instanceof Array&&(b=b[0]),this._data=b.slice(),this.length=this._data.length;for(let a=Math.floor(this.length/2)-1;0<=a;a--)this._siftDown(a)}}_swap(a,b){let c=this._data[a];this._data[a]=this._data[b],this._data[b]=c}_siftUp(a){for(;0<a&&0<this.cmpFct(this._data[Math.floor((a-1)/2)],this._data[a]);)this._swap(a,Math.floor((a-1)/2)),a=Math.floor((a-1)/2)}_siftDown(a){for(let b;2*a+1<this.length;){if(b=2*a+2>=this.length?2*a+1:0>this.cmpFct(this._data[2*a+1],this._data[2*a+2])?2*a+1:2*a+2,0>=this.cmpFct(this._data[a],this._data[b]))return;this._swap(a,b),a=b}}min(){if(0==this.length)throw new RangeError("BinaryHeap: can't call min() on an empty heap.");return this._data[0]}deleteMin(){let a=this._data[0];return this.length--,this._data[0]=this._data[this.length],this._data.pop(),this._siftDown(0),a}insert(a){this._data[this.length]=a,this._siftUp(this.length),this.length++}isEmpty(){return 0==this.length}}class PriorityQueue extends CustomBinaryHeap{constructor(a=(c,a)=>c-a,...b){super(a,...b)}}class BinomialTreeNode{constructor(a){this.key=a,this.children=[]}min(){return this.key}rank(){return this.children.length}deleteMin(){const a=this.children.slice();return this.children=[],a}addChild(a){if(!(a instanceof BinomialTreeNode))throw new Error("BinomialTreeNode: child must be of type BinomialTreeNode.");if(a.rank()!=this.rank())throw new Error("BinomialTreeNode: Can't add tree of rank "+a.rank()+" to a tree of rank "+this.rank()+".");return this.children.push(a),this}}function merge(c,a){return c.min()<=a.min()?c.addChild(a):a.addChild(c)}class BinomialHeap{constructor(...a){if(this._trees=[],this.length=0,0<a.length)if(a[0]instanceof Array&&(a=a[0]),1==a.length&&!(a[0]instanceof BinomialTreeNode))this._trees.push(new BinomialTreeNode(a[0])),this.length=1;else for(let b=0;b<a.length;b++)this._trees.push(a[b]),this.length+=1<<a[b].rank()}min(){if(0==this._trees.length)throw new RangeError("BinomialHeap: can't call min() on an empty heap.");let a=1/0;for(let b=0;b<this._trees.length;b++)this._trees[b].min()<a&&(a=this._trees[b].min());return a}insert(a){const b=new BinomialHeap(a);this.mergeWith(b)}deleteMin(){if(0==this._trees.length)throw new RangeError("Can't call deleteMin() on an empty heap.");let a=1/0,b=null,c=0;for(let d=0;d<this._trees.length;d++)this._trees[d].min()<a&&(a=this._trees[d].min(),b=this._trees[d],c=d);const d=new BinomialHeap(b.deleteMin());return this.length-=d.length+1,this._trees.splice(c,1),this.mergeWith(d),a}mergeWith(c){let d=0,e=0;const f=[];let g=-1;for(this.length+=c.length;d<this._trees.length||e<c._trees.length;){let h=null,a=null,b=1/0,i=1/0;if(d<this._trees.length&&(h=this._trees[d],b=h.rank()),e<c._trees.length&&(a=c._trees[e],i=a.rank()),b<i)d++;else if(b>i){e++;const c=i,d=a;i=b,a=h,b=c,h=d}let j;if(b==i?(d++,e++,j=merge(h,a)):j=h,j.rank()>g)f.push(j),g=j.rank();else{if(j.rank()<g)throw new Error("The developer obviously didn't understand how binomial heaps work...");j=merge(j,f[f.length-1]),f[f.length-1]=j,g=j.rank()}}this._trees=f}isEmpty(){return 0==this._trees.length}}class E{constructor(a){this.v=a}}class WE{constructor(a,b){this.v=a,this.w=b}}class Graph{constructor(a){this.n=a,this._weighted=!1,this.adjList=[],this.adjListRev=[],this._nodeMap=new Map;for(let b=0;b<this.n;b++)this.adjList[b]=[],this.adjListRev[b]=[]}dijkstra(a){const b=[];for(let c=0;c<this.n;c++)b[c]=1/0;b[a]=0;const c=new PriorityQueue((c,a)=>c[0]-a[0]);for(c.insert([0,a]);!c.isEmpty();){const[a,d]=c.deleteMin();if(a==b[d])for(let e=0;e<this.adjList[d].length;e++){const f=this.adjList[d][e].v,g=a+this.adjList[d][e].w;g<b[f]&&(b[f]=g,c.insert([g,f]))}}return b}getSCCGraph(){const a=[],b=[],c=[],d=-1,e=0,f=[];let g=0;for(let e=0;e<this.n;e++)a[e]=d,b[e]=d,c[e]=d,f[e]=-1;const h=new Queue,i=new Queue,j=[],k=[],l=m=>{const n=new Set;a[m]=b[m]=g++,h.pushBack(m),i.pushBack(n),c[m]=e;for(let g=0;g<this.adjList[m].length;g++){const h=this.adjList[m][g].v;if(b[h]==d){const a=l(h);-1!=a&&n.add(a)}else-1!=f[h]&&n.add(f[h]);c[h]==e&&(a[m]=Math.min(a[m],a[h]))}if(a[m]==b[m]){const a=[];for(;;){const b=h.popBack();c[b]=1,f[b]=j.length,a.push(this.getNode(b));const d=i.popBack();if(m==b)break;for(const a of d)n.add(a)}j.push(a);for(const a of n)k.push([j.length-1,a]);return j.length-1}return-1};for(let a=0;a<this.n;a++)b[a]==d&&l(a);const m=new Graph(j.length);for(let a=0;a<k.length;a++)m.insertEdge(k[a][0],k[a][1]);for(let a=0;a<j.length;a++)m.setNode(a,j[a]);return m}topSort(){const a=[];let b=0;const c=[],d=new Queue;for(let e=0;e<this.n;e++)a[e]=this.adjList[e].length,0==a[e]&&(b++,d.pushBack(e),c.push(this.getNode(e)));for(;!d.isEmpty();){const e=d.popFront();for(let f=0;f<this.adjListRev[e].length;f++){const g=this.adjListRev[e][f].v;a[g]--,0==a[g]&&(b++,d.pushBack(g),c.push(this.getNode(g)))}}return b==this.n?c.reverse():null}isAcyclic(){return null!==this.topSort()}insertEdge(a,b,c){"number"==typeof c?(this.adjList[a].push(new WE(b,c)),this.adjListRev[b].push(new WE(a,c)),this._weighted=!0):(this.adjList[a].push(new E(b)),this.adjListRev[b].push(new E(a)))}insertUndirectedEdge(a,b,c){this.insertEdge(a,b,c),this.insertEdge(b,a,c)}getNode(a){return this._nodeMap.has(a)?this._nodeMap.get(a):a}setNode(a,b){this._nodeMap.set(a,b)}getAllNodes(){const a=[];for(let b=0;b<this.n;b++)a.push(this.getNode(b));return a}}class HashSet{constructor(a=b=>b){this._toKeyFct=a,this._hashMap={},this.length=0}insert(a){this._hashMap.hasOwnProperty(this._toKeyFct(a))||(this._hashMap[this._toKeyFct(a)]=a,this.length++)}remove(a){this._hashMap.hasOwnProperty(this._toKeyFct(a))&&(this._hashMap[this._toKeyFct(a)]=void 0,delete this._hashMap[this._toKeyFct(a)],this.length--)}find(a){return this._hashMap.hasOwnProperty(this._toKeyFct(a))}contains(a){return this.find(a)}toArray(){const a=[];for(const b in this._hashMap)this._hashMap.hasOwnProperty(b)&&a.push(this._hashMap[b]);return a}isEmpty(){return 0==this.length}}class ListHashSet{constructor(a=b=>b){this._toKeyFct=a,this._hashMap={},this.list=new DoublyLinkedList}get length(){return this.list.length}insert(a){"undefined"==typeof this._hashMap[this._toKeyFct(a)]&&(this._hashMap[this._toKeyFct(a)]=this.list.pushBack(a))}remove(a){"undefined"!=typeof this._hashMap[this._toKeyFct(a)]&&(this.list.removeLink(this._hashMap[this._toKeyFct(a)]),this._hashMap[this._toKeyFct(a)]=void 0)}find(a){return"undefined"!=typeof this._hashMap[this._toKeyFct(a)]}contains(a){return this.find(a)}toArray(){return this.list.toArray()}isEmpty(){return 0==this.length}}class SingleLink{constructor(a,b){this.data=a,this.next=b}}class DoubleLink{constructor(a,b,c){this.data=a,this.last=b,this.next=c}}class LinkedList{constructor(...a){if(1==a.length&&a[0]instanceof Array&&(a=a[0]),this.length=0,this.first=null,0<a.length){a=a.slice().reverse(),this.length=a.length,this.first=new SingleLink(a[0],null);let b=this.first;for(let c=1;c<this.length;c++)b.next=new SingleLink(a[c],null),b=b.next}}get(a){if(0>a)throw new RangeError("LinkedList: index "+a+" is out of bounds length is "+this.length+".");if(a>=this.length)throw new RangeError("LinkedList: index "+a+" is out of bounds length is "+this.length+".");a=this.length-a-1;let b=this.first;for(let c=0;c<this.length;c++){if(c==a)return b.data;b=b.next}}removeIdx(a){if(0>a)throw new RangeError("LinkedList: index "+a+" is out of bounds length is "+this.length+".");if(a>=this.length)throw new RangeError("LinkedList: index "+a+" is out of bounds length is "+this.length+".");if(a=this.length-a-1,0==a)this.first=this.first.next;else{let b=this.first,c=this.first.next;for(let d=1;d<this.length;d++){if(d==a){b.next=c.next;break}b=c,c=c.next}}this.length--}removeObj(a){let b=!1;if(a===this.first.data)this.first=this.first.next,b=!0;else{let c=this.first,d=this.first.next;for(let e=1;e<this.length;e++){if(a===d.data){c.next=d.next,b=!0;break}c=d,d=d.next}}return b&&this.length--,b}contains(a){let b=this.first;for(let c=0;c<this.length;c++){if(a===b.data)return!0;b=b.next}return!1}pushBack(a){this.first=new SingleLink(a,this.first),this.length++}getBack(){if(0==this.length)throw new RangeError("LinkedList: cannot get last element from empty list.");return this.first.data}popBack(){if(0==this.length)throw new RangeError("LinkedList: cannot pop last element from empty list.");const a=this.first.data;return this.first=this.first.next,this.length--,a}isEmpty(){return 0==this.length}toString(){let a="]",b=this.first;for(let c=0;c<this.length;c++)0<c&&(a=", "+a),a=b.data+a,b=b.next;return a="LinkedList: ["+a,a}}class DoublyLinkedList{constructor(...a){if(1==a.length&&a[0]instanceof Array&&(a=a[0]),this.length=0,this.first=null,this.last=null,0<a.length){this.length=a.length,this.first=new DoubleLink(a[0],null,null);let b=this.first;for(let c=1;c<this.length;c++)b.next=new DoubleLink(a[c],b,null),b=b.next;this.last=b}}get(a){if(0>a)throw new RangeError("DoublyLinkedList: index "+a+" is out of bounds length is "+this.length+".");if(a>=this.length)throw new RangeError("DoublyLinkedList: index "+a+" is out of bounds length is "+this.length+".");let b=this.first;for(let c=0;c<this.length;c++){if(c==a)return b.data;b=b.next}}removeIdx(a){if(0>a)throw new RangeError("DoublyLinkedList: index "+a+" is out of bounds length is "+this.length+".");if(a>=this.length)throw new RangeError("DoublyLinkedList: index "+a+" is out of bounds length is "+this.length+".");if(0==a)this.first=this.first.next,null!==this.first&&(this.first.last=null);else{let b=this.first,c=this.first.next;for(let d=1;d<this.length;d++){if(d==a){b.next=c.next,null===c.next?this.last=b:c.next.last=b;break}b=c,c=c.next}}this.length--}removeObj(a){let b=!1;if(a===this.first.data)this.first=this.first.next,null!==this.first&&(this.first.last=null),b=!0;else{let c=this.first,d=this.first.next;for(let e=1;e<this.length;e++){if(a===d.data){c.next=d.next,null===d.next?this.last=c:d.next.last=c,b=!0;break}c=d,d=d.next}}return b&&this.length--,b}removeLink(a){if(0==this.length)throw new RangeError("DoublyLinkedList: cannot remove element from empty list.");if(null==a.last&&null==a.next){if(this.first!=a||1!=this.length)throw new Error("DoublyLinkedList: cannot remove link that is not part of the list");this.first=this.last=null}else if(null==a.last){if(this.first!=a)throw new Error("DoublyLinkedList: cannot remove link that is not part of the list");this.first=a.next,a.next.last=null}else if(null==a.next){if(this.last!=a)throw new Error("DoublyLinkedList: cannot remove link that is not part of the list");this.last=a.last,a.last.next=null}else{const b=a.next,c=a.last;b.last=c,c.next=b}this.length--}insertAfter(a,b){const c=a.next;if(null==c){if(this.last!=a)throw new Error("DoublyLinkedList: cannot add element after link that is not part of the list");return this.pushBack(b)}const d=a.next=c.last=new DoubleLink(b,a,c);return this.length++,d}insertBefore(a,b){const c=a.last;if(null==c){if(this.first!=a)throw new Error("DoublyLinkedList: cannot add element before link that is not part of the list");return this.pushFront(b)}const d=a.last=c.next=new DoubleLink(b,c,a);return this.length++,d}insertLinkAfter(a,b){const c=a.next;if(null==c){if(this.last!=a)throw new Error("DoublyLinkedList: cannot add element after link that is not part of the list");return this.last=b,this.last.next=null,this.last.last=a,a.next=this.last,this.length++,b}const d=a.next=c.last=b;return b.last=a,b.next=c,this.length++,d}insertLinkBefore(a,b){const c=a.last;if(null==c){if(this.first!=a)throw new Error("DoublyLinkedList: cannot add element before link that is not part of the list");return this.first=b,this.first.last=null,this.first.next=a,a.last=this.first,this.length++,b}const d=a.last=c.next=b;return b.last=c,b.next=a,this.length++,d}contains(a){let b=this.first;for(let c=0;c<this.length;c++){if(a===b.data)return!0;b=b.next}return!1}pushBack(a){let b;return 0==this.length?b=this.last=this.first=new DoubleLink(a,null,null):(b=this.last.next=new DoubleLink(a,this.last,null),this.last=this.last.next),this.length++,b}getBack(){if(0==this.length)throw new RangeError("DoublyLinkedList: cannot get last element from empty list.");return this.last.data}popBack(){if(0==this.length)throw new RangeError("DoublyLinkedList: cannot pop last element from empty list.");const a=this.last.data;return this.last=this.last.last,null===this.last?this.first=null:this.last.next=null,this.length--,a}pushFront(a){let b;return 0==this.length?b=this.last=this.first=new DoubleLink(a,null,null):(b=this.first.last=new DoubleLink(a,null,this.first),this.first=this.first.last),this.length++,b}getFront(){if(0==this.length)throw new RangeError("DoublyLinkedList: cannot get first element from empty list.");return this.first.data}popFront(){if(0==this.length)throw new RangeError("DoublyLinkedList: cannot pop first element from empty list.");const a=this.first.data;return this.first=this.first.next,null===this.first?this.last=null:this.first.last=null,this.length--,a}toArray(){const a=[];let b=this.first;for(let c=0;c<this.length;c++)a.push(b.data),b=b.next;return a}isEmpty(){return 0==this.length}toString(){let a="DoublyLinkedList: [",b=this.first;for(let c=0;c<this.length;c++)0<c&&(a+=", "),a+=b.data,b=b.next;return a+="]",a}}class Queue{constructor(...a){1==a.length&&a[0]instanceof Array&&(a=a[0]),this._data=a.slice(),this._front=0,this._last=a.length-1,this._size=16,0<a.length?this._size=Math.max(16,1<<Math.ceil(Math.log2(a.length))):this._front=1}get(a){if(0>a)throw new RangeError("Queue: index "+a+" is out of bounds length is "+this.length+".");if(a>=this.length)throw new RangeError("Queue: index "+a+" is out of bounds length is "+this.length+".");return this._data[(this._front+a)%this._size]}contains(a){for(let b=0;b<this.length;b++)if(this._data[(this._front+b)%this._size]===a)return!0;return!1}removeObj(a){let b=-1;for(let c=0;c<this.length;c++)if(this._data[(this._front+c)%this._size]===a){b=c;break}return-1!=b&&(this.removeIdx(b),!0)}removeIdx(a){if(0>a)throw new RangeError("Queue: index "+a+" is out of bounds length is "+this.length+".");if(a>=this.length)throw new RangeError("Queue: index "+a+" is out of bounds length is "+this.length+".");for(let b=a;b<this.length;b++)this._data[b%this._size]=this._data[(b+1)%this._size];--this._last,0>this._last&&(this._last=this._size-1),this._checkFrontShift()}get length(){return 0>this._last?0:this._last>=this._front?this._last-this._front+1:this._size-this._front+this._last+1}_checkFrontShift(){if(this.length<this._size/4){let a=[];for(let b=0;b<this.length;b++)a[b]=this._data[(this._front+b)%this._size];this._data=a,this._front=0,this._last=this._data.length-1,this._size=Math.max(16,1<<Math.ceil(Math.log2(this._data.length)),this._size/2)}}pushBack(a){if(0==this.length)this._data.push(a),this._front=this._last=0;else if(this._last>=this._front)this._data[++this._last]=a,this._last>=this._size&&(this._size*=2);else if(this._last<this._front-1)this._data[++this._last]=a;else{for(let a=0;a<this._size-this._front;a++)this._data[this._front+this._size+a]=this._data[this._front+a];this._front+=this._size,this._size*=2,this._data[++this._last]=a}}getBack(){if(0==this.length)throw new RangeError("Queue: cannot get last element from empty queue.");return this._data[this._last]}popBack(){if(0==this.length)throw new RangeError("Queue: cannot pop last element from empty queue.");const a=this._data[this._last];return 1==this.length?(this._data=[],this._front=1,this._last=-1,this._size=16,a):(--this._last,0>this._last&&(this._last=this._size-1),this._checkFrontShift(),a)}pushFront(a){if(0==this.length)this._data.push(a),this._front=this._last=0;else if(this._last>=this._front)0<this._front?this._data[--this._front]=a:(this._last==this._size-1&&(this._size*=2),this._front=this._size-1,this._data[this._front]=a);else if(this._last<this._front-1)this._data[--this._front]=a;else{for(let a=0;a<this._size-this._front;a++)this._data[this._front+this._size+a]=this._data[this._front+a];this._front+=this._size,this._size*=2,this._data[--this._front]=a}}getFront(){if(0==this.length)throw new RangeError("Queue: cannot get last element from empty queue.");return this._data[this._front]}popFront(){if(0==this.length)throw new RangeError("Queue: cannot pop first element from empty queue.");const a=this._data[this._front];return 1==this.length?(this._data=[],this._front=1,this._last=-1,this._size=16,a):(++this._front,this._front>=this._size&&(this._front=0),this._checkFrontShift(),a)}isEmpty(){return 0==this.length}toString(){let a="Queue: [";for(let b=0;b<this.length;b++)0<b&&(a+=", "),a+=this._data[(this._front+b)%this._size];return a+="]",a}}